*  Описание тестового
*** Общий контекст
Оригинал см в pdf

Компания разрабатывает новый протокол аутентификации. Криптографы компании исследовали альтернативы хэшированию паролей и обнаружили, что доказательство с нулевым разглашением (ZKP) является жизнеспособной альтернативой хэшированию в схеме аутентификации. Более того, криптографы нашли протокол ZKP, подходящий для этой цели. Вы приняли вызов по внедрению протокола ZKP и тестового приложения, использующего этот протокол для регистрации и аутентификации пользователей.

Мы хотим адаптировать протокол ZKP, описанный в "Cryptography: An Introduction (3rd Edition) Nigel Smart" page 377 section "3. Sigma Protocols" subsection "3.2. Chaum–Pedersen Protocol" для поддержки 1-факторной аутентификации, то есть точного совпадения регистрационного пароля (числа), сохраненного при регистрации, и другого числа (логин-пароля), сгенерированного в процессе входа в систему. Теперь мы опишем процессы регистрации и входа в систему.

Процесс регистрации:

Проверяющий (клиент) имеет секретный пароль x (т.е. это число) и желает зарегистрировать его на верификаторе (сервере). Чтобы сделать это, они вычисляют (!см ниже!) y1 и y2, используя общедоступные g и h и секретный пароль x, и отправляют верификатору вычисленные y1 и y2.

Скорее всего тут ошибка в тексте тестового:
"To do that, they calculate y1 and y2 using public g and h and the secret x and
sends to the verifier y1, y2" - если sends, то "отправлет", т.е. отправляет клиент, а следовательно, вычисляет тоже он. Т.е. должно быть: To do that, IT CALCULATES y1 and y2 using public g and h and the secret x and sends to the verifier y1, y2.

Процесс логина:
Процесс описан на диаграмме в pdf-файле.
- prover (он же клиент) является частью аутентифицируемой стороной
- verifier (т.е. сервер) выполняет аутентификационную проверку
- y1 = g^x и y2 = h^x - это публичная информация

Если попробовать описать словами, то получается следующее:
- клиент генерирует число k, затем возводит число g и h в степень k, получая таким образом числа r1 и r2. Т.е. r1 = g^k и r2 = h^k
- r1 и r2 отправляются на сервер
- сервер генерирует рандомное число С и отправляет его клиенту
- клиент вычисляет число S, где s = k - c * x (mod q) [TODO:gmm] откуда взялось q???
- число s отправляется на сервер

Аутентификация считается успешной, если r1 = g^s * y1^c AND r2 = h^s * y2^c

*** Основное задание

Разработайте и напишите код, реализующий протокол ZKP, описанный выше. Решение должно быть реализовано как сервер и клиент с использованием протокола gRPC в соответствии с предоставленным интерфейсом, описанным в схеме “protobuf”. Код должен реализовывать очень простые серверные и клиентские приложения. Мы хотели бы видеть, как вы думаете о проблеме и подходите к ней, поэтому было бы полезно простое описание вашего подхода и того, как вы хотели бы его расширить или интегрировать.

*** Бонусные требования
Следующие пункты - это все то, что было бы неплохо увидеть в рабочей реализации.
Ни один из них не является обязательным, но если есть какие-либо из этих пунктов, которые вы можете добавить к своему приложению, это было бы полезно для нас при определении уровня вашего приложения.

- Модульные тесты, где это уместно

- Функциональный тест протокола ZKP

- Настройка для запуска клиента и сервера.

- Используйте Rust в качестве языка для реализации

- Производительность и оптимизация

- Охват тестовых примеров (не охват кода)

- Надежность кода

- Организация кода

- Качество кода

- Хорошо документированный код

- Каждый экземпляр запускается в отдельном контейнере docker и имеет docker compose для запуска установки

- Существует код для развертывания двух контейнеров в AWS. Клиент на одном компьютере и сервер на другом компьютере

- Реализуйте два варианта: один с возведением в степень (как описано в книге) и один с использованием криптографии с эллиптической кривой (смотрите, например, эту реализацию ZKP в Rust).

- Разрешить использование чисел “BigInt”
*** Разжовывание
Лучшее объяснение
https://crypto.stackexchange.com/questions/99262/chaum-pedersen-protocol

Тестовое отсылает нас к "Cryptography: An Introduction (3rd Edition) Nigel Smart" page 377 section "3. Sigma Protocols" subsection "3.2. Chaum–Pedersen Protocol"

Переводим и разжовываем.

Допустим, есть 2 дискретных логарифма y1 = g^x1 и y2 = h^x2, где x1 = x2, т.е. мы хотим доказать, что знаем дискретный логарифм и при этом доказываем, что скрытые дискретные логарифмы равны. (Т.е. фактически мы доказываем, что знаем x1 и x2 и при этом доказываем, что x1 = x2, т.е. что это одно и то же число).

Дальше: We assume that g and h generate groups of prime order q, and we denote the common discrete logarithm by x ease notation - это требует отдельного разъяснения.
Перевод: Мы предполагаем, что g и h порождают группы простого порядка q, и обозначим общий дискретный логарифм с помощью обозначения x в простой нотации.

Разжовывание:
1. Математическая группа - это алгебраическая структура, состоящая из множества элементов и бинарной операции, которая удовлетворяет определенным аксиомам.
Группа определяется следующим образом:
- Множество элементов: Есть некоторое множество G, которое содержит элементы, называемые элементами группы. Эти элементы могут быть числами, матрицами, функциями и так далее.

- Бинарная операция: На множестве G определена бинарная операция (часто обозначаемая ⋅ или ∗), которая сопоставляет каждой упорядоченной паре элементов (a,b) в G новый элемент a⋅b (или a∗ b) в том же множестве G. Бинарная операция должна быть замкнутой, то есть результат операции также должен принадлежать множеству G.

- Аксиомы группы: Группа должна удовлетворять следующим аксиомам:
  a. Ассоциативность: Для всех элементов a,b,c из G операция должна быть ассоциативной, то есть (a⋅b)⋅c=a⋅(b⋅c)
  b. Существование нейтрального элемента: Существует элемент e, такой что для всех элементов a из G выполняется a ⋅ e = e ⋅ a = a
  c. Существование обратного элемента: Для каждого элемента a из G существует элемент a^-1 (называемый обратным элементом), такой что a^-1 = a^-1 * a = e, где e - нейтральный элемент.

Например, все целые числа можно считать группой. Потому что:
- есть множество целых чисел
- над множеством этим множеством есть бинарная операция - сложение. Потому что если сложить два целых числа, то сумма этих двух чисел тоже будет целым числом, а следовательно будет частью множества целых чисел
- операция сложения ассоциативна: если a = 1, b = 2, c = 3, то (1+2)+3 = 6 && 1 + (2+3) = 6 т.е. (a⋅b)⋅c=a⋅(b⋅c)
- существует единичный элемент - это 0. Если взять любое число и сложить с нулем, то получится то же число, как слагаемые не переставляй
- для каждого числа в группе сущетсвует обратный элемент: для положительных чисел обратные элементы - это отрицательные числа и наоборот

2. Порядок группы - это сколько элементов с ней содержится

3. Группы простого порядка - это такие группы, где количество элементов является простым числом, в такой группе нет подгрупп.
Пример группы простого порядка:

Группа А​: Это группа целых чисел по модулю простого числа P, где операция сложения выполняется по модулю P. Группа имеет порядок P и является группой простого порядка.
Элементы множества будут от 0 до P - 1.

Допустим, P = 7. Тогда элементы множества будут числа от 0 до 6. Бинарная операция - это операция сложения по модулю Р. Это означает, что результат сложения двух элементов a и b
в множества А равен (a + b) mod Р, где mod обозначает операцию взятия остатка от деления. Например, 3 + 4 = 0 поскольку 3 + 4 = 7  и 7 mod 7 = 0.

4. Простое число - это такое число, которые можно разделить без остатка ТОЛЬКО на 1 и на самого себя. Т.е. 5, 7, 11, 13, 17 и т.д.

5. Взаимно простые числа - это такие числа, у которых наибольший общий делитель = 1. Например, 5 и 6 или 6 и 11 и т.д.

6. Как породить группу простого порядка, имея 2 числа (пусть будут g и h):
Элементы g и h должны порождать циклическую подгруппу в группе.

- Определите группу, в которой вы хотите создать циклическую подгруппу. Например, возьмем группу целых чисел по модулю некоторого простого числа p

- Проверьте, что g и h оба принадлежат этой группе

- Создайте циклическую подгруппу, порождаемую элементом g. Для этого вы можете взять все степени g, начиная с 1, и продолжая до тех пор, пока не получите нейтральный элемент (e) группы. Например: g, g^2, g^3, g^4, ... пока g^n не станет равным e - нейтральному элементу группы.

- Теперь, если g^m = e (где m - наименьшая положительная степень, при которой g^m = e), вы можете сформировать циклическую подгруппу H, которая состоит из {g, g^2, g^3, ..., g^(m-1)}. Эта подгруппа будет иметь порядок m.

- Если h принадлежит этой циклической подгруппе H (то есть h = g^k, где k - некоторое целое число), то вы можете использовать g и h для генерации группы простого порядка. Группа будет состоять из элементов {e, g, g^2, ..., g^(m-1), h, g*h, g^2*h, ..., g^(m-1)*h}.

Это общий пример вычислений.

Возвращаемся к "We assume that g and h generate groups of prime order q, and we denote the common discrete logarithm by x ease notation".

У нас есть некоторые группы простого порядка Q - т.е. группы, которые состоят из элементов, чье количество = простому числу.
Допустим, у нас есть группы прямого порядка 11 - т.е. в этих группах будет по 11 элементов (но мы не знаем, каких). И есть некоторые 2 числа g и h, которые могут порождать эти
группы, следуя алгоритму выше. Мы предполагаем, что это в принципе возможно.

*** Пример вычислений
Лучшее объяснение


Нужно выбрать p = некое простое число.
затем найти g, h и q, такие, что:

 g^q mod p =  1
 h^q mod p = 1,

Как это сделать:
если p - всегда простое число, то q всегда будет p - 1
g и h - любые числа, не кратные q

Тогда приводим пример вычислений:
------------
q = 11

p = 23

g = 4
h = 9

x = 6

k = 7

c = 5


тогда:
y1 = g^x (mod p) = 4^6 (mod 23) = 2
y2 = h^x (mod p) = 9 ^ 6 (mod 23) = 3

тогда:
r1 = g^k (mod p) = 4 ^ 7 (mod 23) = 8
r2 = h^k (mod p) = 9 ^ 7 (mod 23) = 4

тогда:
s = (k - c * x) (mod q) = (7 - 5 * 6) (mod 11) = 10

тогда:
r1 = (g^s * y1 ^c) (mod p)= (4^10 * 2^5) (mod 23) = 8
r2 = (h^s * y2 ^c) (mod p) = (9^10 * 3^5) (mod 23) = 4


---------

p = 37

q = 36

g = 4
h = 9

x = 6

k = 7

c = 5

тогда:
y1 = g^x (mod p) = 4^6 (mod 37) = 26
y2 = h^x (mod p) = 9 ^ 6 (mod 37) = 10

тогда:
r1 = g^k (mod p) = 4 ^ 7 (mod 37) = 30
r2 = h^k (mod p) = 9 ^ 7 (mod 37) = 16

тогда:
s = (k - c * x) (mod q) = (7 - 5 * 6) (mod 36) = 13

тогда:
r1 = (g^s * y1 ^c) (mod p)= (4^13 * 26^5) (mod 37) = 30
r2 = (h^s * y2 ^c) (mod p) = (9^13 * 10^5) (mod 37) = 16


----
q = 11

g = 4

h = 9

x = 6

k = 7

c = 5

y1 = g^x  = 4^6  = 4096
y2 = h^x  = 9^6  = 531441

r1 = 16384
r2 = 4782969

s = (7 - 5 * 6) mod 11 = 10
